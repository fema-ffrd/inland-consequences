"""
Inland flood vulnerability function implementation.

This module provides vulnerability calculations specific to inland flooding
using FLSBT (Flood-Specific Building Types) based damage function lookup.
"""

import re
from pathlib import Path
from typing import Optional
import numpy as np
import pandas as pd
from sphere.core.schemas.buildings import Buildings
from sphere.core.schemas.field_mapping import FieldMapping
from sphere.core.schemas.abstract_vulnerability_function import AbstractVulnerabilityFunction


class InlandFloodVulnerability(AbstractVulnerabilityFunction):
    """
    Inland flood vulnerability function implementation.
    
    This class implements flood-specific vulnerability calculations using
    a two-stage lookup process:
    1. Match building attributes to damage function IDs via complete lookup tables
    2. Interpolate damage percentages from depth-damage curves using those IDs
    
    The lookup process considers:
    - Construction type (C, M, S, W)
    - Occupancy type (RES1, COM1, etc.)
    - Number of stories (with min/max ranges)
    - Square footage (optional filtering)
    - Foundation type (BASE, PILE, SHAL, SLAB)
    - Flood peril type (RLS, RHS, RLL, RHL, CST, CMV, CHW)
    """
    
    def __init__(
        self,
        buildings: Buildings,
        lookup_table_dir: Optional[str] = None,
    ):
        """
        Initialize InlandFloodVulnerability with lookup tables.
        
        Args:
            buildings (Buildings): Buildings object containing building inventory data.
            lookup_table_dir (str, optional): Directory containing lookup table CSV files.
                Defaults to 'outputs/' relative to the repository root.
        
        Raises:
            FileNotFoundError: If lookup table files cannot be found.
            ValueError: If lookup tables have invalid structure.
        """
        self.buildings = buildings
        
        # Determine lookup table directory
        if lookup_table_dir is None:
            # Default to outputs/ directory relative to repository root
            repo_root = Path(__file__).parent.parent.parent
            lookup_table_dir = repo_root / "outputs"
        else:
            lookup_table_dir = Path(lookup_table_dir)
        
        # Load building (structural) damage function lookup table
        bldg_lookup_path = lookup_table_dir / "complete_lookup_table.csv"
        if not bldg_lookup_path.exists():
            raise FileNotFoundError(
                f"Building damage lookup table not found: {bldg_lookup_path}"
            )
        self.building_lookup = pd.read_csv(bldg_lookup_path)
        
        # TODO: Validate building_lookup columns
        # Expected: Construction_Type, Occupancy_Type, Story_Min, Story_Max,
        #           SQFT_Min, SQFT_Max, FLSBT_Range, Foundation_Type,
        #           Flood_Peril_Type, Damage_Function_ID
        
        # Load contents damage function lookup table
        cont_lookup_path = lookup_table_dir / "complete_lookup_table_contents.csv"
        if not cont_lookup_path.exists():
            raise FileNotFoundError(
                f"Contents damage lookup table not found: {cont_lookup_path}"
            )
        self.contents_lookup = pd.read_csv(cont_lookup_path)

        inv_lookup_path = lookup_table_dir / "complete_lookup_table_inventory.csv"
        if not inv_lookup_path.exists():
            raise FileNotFoundError(
                f"Inventory damage lookup table not found: {inv_lookup_path}"
            )
        self.inventory_lookup = pd.read_csv(inv_lookup_path)

        # Damage curve lookup tables (depth -> percent damage)
        # TODO: Determine source of actual depth-damage curves
        # From Damage_Function_Deliverable_2-5-2024.xlsx (where will these be stored?)
        self.building_curves = None  # TODO: Load building damage curves
        self.contents_curves = None  # TODO: Load contents damage curves
        self.inventory_curves = None  # TODO: Load inventory damage curves (when ready)
    
    def calculate_vulnerability(self):
        """
        Calculate vulnerability percentages for buildings based on flood characteristics.
        
        This is the main method that orchestrates the vulnerability calculation:
        1. Assigns damage function IDs to buildings based on attributes
        2. Calculates damage percentages using assigned IDs and flood depths
        
        The results are stored directly in the buildings.gdf DataFrame with columns:
        - bddf_id: Building damage function ID
        - cddf_id: Contents damage function ID
        - iddf_id: Inventory damage function ID (when available)
        - building_damage_percent: Structural damage percentage
        - content_damage_percent: Contents damage percentage
        - inventory_damage_percent: Inventory damage percentage (when available)
        """
        # Step 1: Assign damage function IDs based on building attributes
        self._assign_damage_function_ids()
        
        # Step 2: Calculate damage percentages using IDs and flood depths
        self.apply_damage_percentages()
    
    def _assign_damage_function_ids(self):
        """
        Assign damage function IDs to buildings via vectorized lookup.
        
        This method matches building attributes against the complete lookup tables
        to assign appropriate damage function IDs for building, contents, and
        inventory damage calculations.
        
        Matching criteria:
        - Construction_Type: Must match exactly
        - Occupancy_Type: Must match exactly
        - Number of stories: Must fall within Story_Min and Story_Max range
        - Square footage: Must fall within SQFT_Min and SQFT_Max (if specified)
        - Foundation_Type: Must match exactly (for building lookup)
        - Flood_Peril_Type: Must match exactly (for building lookup)
        
        TODO: Implement vectorized matching algorithm similar to DefaultFloodVulnerability
        TODO: Handle cases where no match is found (default ID or raise error?)
        TODO: Handle -9999 placeholder values in lookup tables
        TODO: Implement contents lookup with occupancy-based fallbacks
        TODO: Determine how to derive flood_peril_type from building/hazard attributes
        """
        fields = self.buildings.fields
        gdf = self.buildings.gdf
        
        # Initialize damage function ID columns if they don't exist
        for id_col in ['bddf_id', 'cddf_id', 'iddf_id']:
            col_name = fields.get_field_name(id_col)
            if col_name and col_name not in gdf.columns:
                gdf[col_name] = None
        
        # TODO: Validate required columns exist in gdf
        # Required: construction_type, occupancy_type, number_stories,
        #           foundation_type, flood_peril_type (or derive it)
        
        # TODO: Clean/normalize building attributes for matching
        # Example: Handle RES3 variations like in DefaultFloodVulnerability
        
        # TODO: Perform vectorized lookup for building damage function IDs
        # Strategy: Create MultiIndex from gdf attributes, match against lookup table
        # Similar to DefaultFloodVulnerability._apply_damage_ids_for_subset
        # but with different matching criteria (story ranges, SQFT ranges, etc.)
        
        # Placeholder: Set all IDs to 0 (no damage) for now
        gdf[fields.get_field_name('bddf_id')] = 0
        gdf[fields.get_field_name('cddf_id')] = 0
        if fields.get_field_name('iddf_id') in gdf.columns:
            gdf[fields.get_field_name('iddf_id')] = 0
    
    def apply_damage_percentages(self):
        """
        Calculate damage percentages using assigned IDs and flood depths.
        
        This method interpolates damage percentages from depth-damage curves
        based on the damage function IDs assigned in _assign_damage_function_ids()
        and the flood depth values in the buildings data.
        
        The interpolation process:
        1. For each building, look up its damage function ID
        2. Retrieve the corresponding depth-damage curve
        3. Interpolate the damage percentage at the building's flood depth
        4. Store the result in the appropriate damage percentage column
        
        TODO: Implement after damage curve source is determined
        TODO: Use similar interpolation logic as DefaultFloodVulnerability._interpolate_from_lookup
        TODO: Handle missing/invalid damage function IDs
        TODO: Determine which depth column to use (flood_depth, depth_in_structure, etc.)
        TODO: Handle depth values outside curve range (extrapolation or capping)
        """
        fields = self.buildings.fields
        gdf = self.buildings.gdf
        
        # Initialize damage percentage columns
        self.buildings.building_damage_percent = pd.NA
        self.buildings.content_damage_percent = pd.NA
        self.buildings.inventory_damage_percent = pd.NA
        
        # TODO: Check if damage curves are loaded
        if self.building_curves is None:
            # Placeholder: Set all damage percentages to 0 for now
            gdf[fields.get_field_name('building_damage_percent')] = 0.0
            gdf[fields.get_field_name('content_damage_percent')] = 0.0
            if fields.get_field_name('iddf_id') in gdf.columns:
                gdf[fields.get_field_name('inventory_damage_percent')] = 0.0
            return
        
        # TODO: Implement interpolation for building damage
        # self._interpolate_from_lookup(
        #     self.building_curves,
        #     fields.get_field_name('depth_in_structure'),  # or 'flood_depth'?
        #     fields.get_field_name('building_damage_percent'),
        #     fields.get_field_name('bddf_id')
        # )
        
        # TODO: Implement interpolation for contents damage
        # self._interpolate_from_lookup(
        #     self.contents_curves,
        #     fields.get_field_name('depth_in_structure'),
        #     fields.get_field_name('content_damage_percent'),
        #     fields.get_field_name('cddf_id')
        # )
        
        # TODO: Implement interpolation for inventory damage (when ready)
        # if fields.get_field_name('iddf_id') in gdf.columns and self.inventory_curves is not None:
        #     self._interpolate_from_lookup(
        #         self.inventory_curves,
        #         fields.get_field_name('depth_in_structure'),
        #         fields.get_field_name('inventory_damage_percent'),
        #         fields.get_field_name('iddf_id')
        #     )
    
    def _interpolate_from_lookup(
        self,
        lookup_df: pd.DataFrame,
        depth_col: str,
        result_col: str,
        id_col: str
    ):
        """
        Interpolate damage percentages from depth-damage curves.
        
        This method can be adapted from DefaultFloodVulnerability._interpolate_from_lookup
        once the damage curve structure is finalized.
        
        Args:
            lookup_df: DataFrame with damage curves (index=damage_function_id,
                columns=depth values like 'ft04m', 'ft00', 'ft01', etc.)
            depth_col: Name of flood depth column in buildings.gdf
            result_col: Name of column to store interpolated damage percentages
            id_col: Name of damage function ID column in buildings.gdf
        
        TODO: Implement vectorized interpolation algorithm
        TODO: Handle negative depth columns (e.g., 'ft04m' for -4 feet)
        TODO: Handle edge cases (depth outside curve range, missing IDs, etc.)
        """
        # Placeholder implementation
        pass
